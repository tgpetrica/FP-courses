##FISIERE IN LIMBAJUL C
Pentru a folosi fisiere trebuie sa folosim un pointer catre FILE ```FILE* ``` si sa includem biblioteca ```stdio.h```.
Deschiderea unui fisier se face cu ajutorul functiei ```fopen``` care are doi parametri de tip pointer catre ```char```: primul este numele fisierului, eventual urmat de calea acestuia, al doilea parametru continand un string care poate contine doar cateva caractere. Aceste caractere, daca apar, arata modul in care va fi folosit fisierul: mod binar, mod tex, mod citire, mod scriere, etc..

| Caracter | Explicatie |
| -------- | -----------|
| ```r```  | Fisierul este deschis pentru operatii de citire. Se presupune ca fisierul exista pe disc si avem acces la el, altfel, pointer catre ```FILE*``` va returna valoarea ```NULL```. |
| ```w``` | Fisierul este deschis pentru operatii de scriere. Daca exista fisierul pe disc, se sterge si va fi creat unul nou; daca nu exista se creeaza unul nou. Deschiderea fisieului in acest mod poate sa esuaze daca fie numele, fie calea sunt gresite sau daca fisierul este deschis deja de aplicatie sau de un program extern aplicatiei sau daca nu avem drepturi de scriere in locatia fisierului. |
| ```b``` | Fisierul este deschis in modul binar, fiind interpretat ca fiind o succesiune de octeti ai tabelei ASCII. In momentul in care ```b``` lipseste sau apare ```t``` inseamna ca fisierul este deschis in modul text, fiind interpretat ca fiind o succesiune de linii, despartite prin caracterul cu codul ASCII = ```13```, codul tastei ```Enter```.  |
| ```a``` | Fisierul este deschis pentru ```append```, adica adaugare la sfarsit. Fisierul poate sa exista sau sa nu existe. Daca exista, fisierul este deschis, iar cursorul se muta la finalul fisierului, fara a se sterge fisierul asa cum face ```w```. Daca nu exista, fisierul este creat.|
| ```+``` | Aparitia caracterului ```+``` arata deschiderea unui fisier in mod mixt. ```r```, desi este un mod de citire, ```r+``` suporta si operatii de scriere. ```w``` este folosit pentru operatii de scriere, dar ```w+``` sunt suportate si operatii de citire. Pentru ```a``` se deschide fisierul in modul scriere cu mutarea cursorului la final pentru scriere, dar ```a+``` poate fi folosit si pentru operatii de citire. |

Ordinea caracterelor in cel de-al doilea string nu este importanta: ```a+b``` = ```ab+```.

```c
char numef[256];
FILE* fis;

printf("Numele fisierului: ");
gets(numef);
fis = fopen(numef, "rb+");
if (fis == NULL)
{
    printf("Eroare! Nu am putut deschide fisierul %s. \n", numef);
    exit(1);
}
```

Odata terminat lucrul cu fisiere, acestea trebuiesc inchise pentru a nu pierde date, folosind functia ```fclose```.
```c
fclose(FILE* fis);
```
Un fisier deschis de o aplicatie ramane deschis pana cand acesta este inchis, timp in care consuma memorie RAM. Orice OS suporta un numar maxim de fisiere ce pot fi deschise de catre o aplicatie. In ziua de azi, acest numar este de peste  zeci de mii de fisiere, dar, desi pare un numar destul de mare, uneori poate fi considerat destul de mic, motiv pentru care fisierele trebuie sa fie inchise.

In momentul in care scriem intr-un fisier folosind o aplicatie, scrierea nu se face direct pe disc, ci intr-o zona tampon, numita **buffer** atasata fisierului din memoria RAM.

In momentul in care inchidem un fisier ne asiguram ca tot ceea ce am scris in acesta ajunge efectiv pe disc. 

Folosind unele compilatoare, in cazul in care nu inchidem un fisier, este posibil ca la inchiderea aplicatiei bufferul atasat fisierului sa nu se goleasca si astfel ca datele sa nu fie salvate pe disc. 

Exista si o functie folosita pentru a inchide toate fisierele deschise de catre o aplicatie: ```fcloseall();```, functie care returneaza numarul de fisiere ce au fost inchise. 

| Functie | Utilizare |
| ------- | --------- |
| ```feof(fis)``` | returneaza ```0``` daca nu s-a ajuns la capatul fisierului sau o valoare nenula daca este sfarsit fisierul |
| ```fflush(fis)``` | goleste bufferul fisierului ```fis```, fortand scrierea datelor din zona de memorie RAM tampon in fisier pe disc. In caz de succes, returneaza 0, altfel returneaza valoarea corespunzatoare constantei ```EOF``` definita in ```stdio.h```. | 
| ```flushall();``` | goleste bufferul tuturor fisierelor deschise |
| ```ferror(fis)``` | verifica daca exista erori in timpul prelucrarii fisierului si in caz afirmativ returneaza o valoare nenula. |
| ```fgetc(fis)``` | citeste un caracter din fisier. Returneaza fie codul caracterului citit, fie ```EOF``` daca s-a ajuns la finalul fisierului. |
| ```fputc(fis)``` | pune un caracter in fisier |
| ```fgets(s, n, fis)``` | fisierul este interpretat ca fiind text: se citeste un sir de caractere de lungime maxima ```n```, care se depune la adresa ```s```. | 
| ```fputs(s, fis)``` | scrie un string ```s``` intr-un fisier |
| ```fprintf(fis, ...)``` | scriere formatata intr-un fisier text |
| ```fscandf(fis, ...)``` | citire formatata in moduul text |
| ```size_t fread(void* p, int nb, int lb, FILE* fis);``` | citire in modul binar; se citesc ```nb``` blocuri de lungime ```lb``` fin fiserul indicat de pointerul ```fis``` si de depun la adresa de memorie ```p```. Returneaza numarul efectiva de blocuri citite din fisier, unde ```size_t``` este un tip de date special definit pentru dimensiuni de blocuri de memorie. |
| ```size_t fread(void* p, int nb, int lb, fis);``` | scrierea in modul binar; se iau ```nb``` blocuri de lungime ```lb``` de la adresa de memorie ```p``` si se scriu in fisierul ```fis```. Returneaza numarul efectiv de blocuri scrise in fisier. 